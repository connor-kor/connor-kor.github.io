---
title: 강의9
category: fullstack-class
---

# 11.15

**[동적 SQL] 필요성**

1. 컴파일 시에 SQL 문장이 확정이 되지 않은 경우. WHERE 조건절, SELECT 항목이 동적으로 변하는 경우
2. PL/SQL 블록 상에서 DDL 문을 실행해야 하는 경우 (CREATE, ATLER, DROP, TRUNCATE 문)
3. PL/SQL 블록 상에서 ALTER 

동적 SQL 을 사용하는 방법

1. 원시 동적 SQL (Native Dynamic SQL: NDS) +++
2. dbms_sql 패키지 사용

동적 SQL 을 실행할 때

```sql
EXECUTE 프로시저명;
```

**형식**

```sql
EXECUTE IMMEDIATE 동적SQL문
[INTO 변수...]
[USING 모드(IN OUT INOUT) 파라미터...]
```

예)

**익명프로시저**

```
20, 7369, SMITH, CLERK
```



```sql
-- ㄱ. 익명프로시저
DECLARE
    vsql VARCHAR2(1000); -- 동적 SQL 을 저장할 변수 선언
    vdeptno emp.deptno%TYPE;
    vempno emp.empno%TYPE;
    vename emp.ename%TYPE;
    Vjob emp.job%TYPE;
BEGIN
    -- 동적 SQL 작성
    vsql := 'SELECT deptno, empno, ename, job ';
    vsql := vsql || 'FROM emp ';
    vsql := vsql || 'WHERE empno = 7369';
    
    -- 동적 SQL 실행
    EXECUTE IMMEDIATE vsql
    INTO vdeptno, vempno, vename, vjob;
    
    dbms_output.put_line(vdeptno || ', ' || vempno || ', ' || vename || ', ' || vjob);
END;
```

> vsql 사이에 띄어쓰기를 꼭 할 것!!

**저장프로시저**

```sql
-- ㄴ. 저장 프로시저
CREATE OR REPLACE PROCEDURE up_nds01 (
    pempno emp.empno%TYPE
)
IS
    vsql VARCHAR2(1000); -- 동적 SQL 을 저장할 변수 선언
    vdeptno emp.deptno%TYPE;
    vempno emp.empno%TYPE;
    vename emp.ename%TYPE;
    Vjob emp.job%TYPE;
BEGIN
    -- 동적 SQL 작성
    vsql := 'SELECT deptno, empno, ename, job ';
    vsql := vsql || 'FROM emp ';
    vsql := vsql || 'WHERE empno = :pempno';
    
    -- 동적 SQL 실행
    EXECUTE IMMEDIATE vsql
    INTO vdeptno, vempno, vename, vjob
    USING pempno;
    
    dbms_output.put_line(vdeptno || ', ' || vempno || ', ' || vename || ', ' || vjob);
END;
```



**dept 테이블에 INSERT 를 수행하는 동적 SQL**

```sql
CREATE OR REPLACE PROCEDURE up_insdept (
    pdname dept.dname%TYPE
    , ploc dept.loc%TYPE
)
IS  
    vsql    VARCHAR2(1000);
    vdeptno dept.deptno%TYPE;
BEGIN
    SELECT max(deptno) + 10 INTO vdeptno
    FROM dept;
    
    vsql := 'INSERT INTO dept ';
    vsql := vsql || 'VALUES (:deptno, :dname, :loc) ';
    
    EXECUTE IMMEDIATE vsql
    USING vdeptno, pdname, ploc;
END;
```

```
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	CHICAGO
40	OPERATIONS	BOSTON
50	QC	
```



```sql
EXEC up_insdept('A', 'B');
```

**테이블 만들기**

```sql
DECLARE 
    vsql VARCHAR2(1000);
BEGIN
    vsql := 'CREATE TABLE tbl_nds (id number, name varchar2(1000))';
    EXECUTE IMMEDIATE vsql;
END;
```

```sql
OPEN 커서명 FOR vsql USING pdeptno;
```

예제

```sql
CREATE OR REPLACE PROCEDURE up_nds02 (
    pdeptno emp.deptno%TYPE
)
IS
    vsql VARCHAR2(1000);
    vCursor SYS_REFCURSOR;
    vrow emp%ROWTYPE;
BEGIN 
    vsql := 'SELECT * ';
    vsql := vsql || 'FROM emp ';
    vsql := vsql || 'WHERE deptno = :deptno ';
    
--    EXECUTE IMMEDIATE vsql USING pdeptno; X 
    OPEN vCursor FOR vsql USING pdeptno;
    LOOP
        FETCH vCursor INTO vrow;
        EXIT WHEN vCursor%NOTFOUND;
        dbms_output.put_line(vrow.ename || ', ' || vrow.job);
    END LOOP;
    CLOSE vCursor;
END;
```

```sql
EXEC up_nds02(30);
```

# 11.16

JavaSE-1.8 뜨게하기

[용어정리]

1. JDBC 란 ?
2. JDBC Driver 란 ?
3. JDBC Driver 의 종류
4. Java + Oracle 연동방법

[JDBC ]

Java DataBase Connectivity 

자바표준 인터페이스

JDBC Driver

Oracle 11g XE

Oracle JDBC Driver == ojdbc6.jar



**설정**

관리도구 - ODBC 데이터 원본(64비트)



(6) Connection 클래스 - J + 연결 + O

1. Class.forName() JDBC Driver (ojdbc6.jar) 로딩
2. DriverManager 클래스 . getConnection() 메서드 -> Connection 객체를 얻어온다.
3. SQL + PL/SQL 질의/응답 작업
4. 연결종료 (Close)

(7) Connection 의 속성

어떤 DB 서버 ? DatabaseName (SID: XE)

계정 ? scott

비밀번호 ? tiger



**JDBC 연동**

ojdbc6.jar 파일을 연결해야 자바 프로젝트를 인식할 수 있다.



프로젝트 우클릭 - Build Path - Configure Build Path

Libraries 탭 -  Add External Jars 로 ojdbc6.jar 선택

```java
String className = "oracle.jdbc.driver.OracleDriver";
String url = "jdbc:oracle:thin:@localhost:1521:xe";
String user = "scott";
String password = "tiger";
Connection conn = null;

try {
    Class.forName(className);
    conn = DriverManager.getConnection(url, user, password);

    System.out.println(conn);
} catch (ClassNotFoundException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
} finally {
    try {
        if (conn != null && !conn.isClosed()) {
            conn.close();
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```



**숏코딩**

```
oracle.jdbc.driver.T4CConnection@60611244
```



```java
String className = "oracle.jdbc.driver.OracleDriver";
String url = "jdbc:oracle:thin:@localhost:1521:xe";
String user = "scott";
String password = "tiger";

Class.forName(className);
Connection conn = DriverManager.getConnection(url, user, password);
```

연결닫기

**DBConn**

```java
public class DBConn {
   private DBConn(){}
   private static Connection connection = null;
   
   public static Connection getConnection() {
      if( connection == null ) { 
         String className = "oracle.jdbc.driver.OracleDriver";
         String url = "jdbc:oracle:thin:@localhost:1521:xe";
         String user = "scott";
         String password = "tiger";         
         try {
            Class.forName(className); 
            connection = DriverManager.getConnection(url, user, password);
         } catch (ClassNotFoundException e) { 
            e.printStackTrace();
         } catch (SQLException e) {
            e.printStackTrace();
         } 
      } // if
      return connection;
   }  // getConnection
   
   public static Connection getConnection(String url, String user, String password) {
	   if( connection == null ) { 
		   String className = "oracle.jdbc.driver.OracleDriver";
		   try {
			   Class.forName(className); 
			   connection = DriverManager.getConnection(url, user, password);
		   } catch (ClassNotFoundException e) { 
			   e.printStackTrace();
		   } catch (SQLException e) {
			   e.printStackTrace();
		   } 
	   } // if
	   return connection;
   }  // getConnection
   
   public static Connection getConnection(String serverName, int port, String sid, String user, String password) {
	   if( connection == null ) { 
		   String className = "oracle.jdbc.driver.OracleDriver";
			String url = String.format("jdbc:oracle:thin:@%s:%d:%s", serverName, port, sid);

		   try {
			   Class.forName(className); 
			   connection = DriverManager.getConnection(url, user, password);
		   } catch (ClassNotFoundException e) { 
			   e.printStackTrace();
		   } catch (SQLException e) {
			   e.printStackTrace();
		   } 
	   } // if
	   return connection;
   }  // getConnection

   public static void close() {
      try { 
         if ( connection != null && !connection.isClosed() ) {
            connection.close();
         }
      } catch (SQLException e) { 
         e.printStackTrace();
      }
      connection = null; // ***
   }
} // class
```

(3) 필요한 작업 - Statement, ResultSet

`Statement` java.beans 가 아니라 java.sql 을 사용한다.

**Connection conn.**

- `createStatement` 

**Statement state.**

- `executeQuery` SELECT
- `executeUpdate()` INSERT, UPDATE, DELETE 

**ResultSet rs.**

- `next()` boolean 을 반환.



```java
// 1 + 2
Connection conn = DBConn.getConnection();

// 3. 필요한 작업 - Statement, ResultSet
String sql = "SELECT * FROM dept"; // DQL(SELECT)
String dname, loc; 

try {
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(sql);

    if (rs.next()) {
        int deptno = rs.getInt(1);
        System.out.printf("%d\n", deptno);
    }

    rs.close(); // 꼭 닫자. ***
} catch (SQLException e) {
    e.printStackTrace();
}

// 4
DBConn.close();
System.out.println("END");
```

# 11.17

**복습**

1-1. 동적 쿼리를 사용하는 저장 프로시저 작성하세요. 
ㄱ. 커서변수 사용
ㄴ. open ~ for 문 사용
ㄷ. 프로시저 안에서  출력까지 하세요.
ㄹ. deptno 를 파라미터로 해서 emp 테이블의
    deptno, ename, hiredate 를 출력하는 
    저장 프로시저 작성.

```sql
CREATE OR REPLACE PROCEDURE sel_emp (
    pdeptno NUMBER
)
IS
    vsql VARCHAR2(1000);
    vdeptno NUMBER(5);
    vename VARCHAR2(50);
    vhiredate DATE;
    vCursor SYS_REFCURSOR;
BEGIN
    vsql := 'SELECT deptno, ename, hiredate FROM emp WHERE deptno = :pdeptno';
    
    OPEN vCursor FOR vsql USING pdeptno;
    LOOP
        FETCH vCursor INTO vdeptno, vename, vhiredate;
        EXIT WHEN vCursor%NOTFOUND;
        
        dbms_output.put_line(vdeptno || ' ' || vename || ' ' || vhiredate);
    END LOOP;
END;
```

ㄱ. JDBC - 자바 표준 인터페이스

ㄴ. Oracle JDBC Driver : ojdbc6.jar + jdbcPro 라이브러리 추가 (참조)

com.util.DBConn 싱글톤 클래스 - getConnection(), close()

ㄷ. JDBC Driver 로딩 : Class.forName()

ㄹ. Connection 객체 : DriverManager.getConnection() 3개 오버로딩

ㅁ. 질의 (SQL) / 응답

ㅂ. 닫기 (close)



5-1. 부서번호를 입력받아서 해당 부서의 모든 사원 정보를 출력 
( 조건 :
ㄱ. 모든 컬럼 출력
ㄴ. 이름 순으로 오름차순정렬
ㄷ. ArrayList 에 부서원 정보 저장
ㄹ. dispEmp( ArrayList list) 출력 메서드 만들어서 정보 출력.
   )      



> DBConn 은 꼭 사용 후 닫을 것!!



```java
public class Ex01 {
   public static void main(String[] args) {
      // 1. EmpDTO/EmpVO 클래스 선언
      ArrayList<EmpDTO> list = null;
      
      // ㄱ. JDBC - 자바 표준 인터페이스
      // ㄴ. Oracle JDBC Driver : ojdbc6.jar + jdbcPro 라이브러리 추가(참조)
      
      // com.util.DBConn 싱글톤 클래스  - getConnection(), close()
//       ㄷ. JDBC Driver 로딩   : Class.forName()
//       ㄹ. Connection 객체    : DriverManager.getConnection() 3개 오버로딩
//       ㅁ. 질의(SQL)/응답
//       ㅂ. 닫기( close ) 
      
      int pdeptno ;
      System.out.print("> 부서번호(deptno) 입력 ? ");
      Scanner scanner =  new Scanner(System.in);
      pdeptno = scanner.nextInt();
      
      String sql  = "SELECT * ";
            sql += "FROM emp ";
            sql += "WHERE deptno =  " + pdeptno ;
            sql += "ORDER BY ename ASC";
      // 
      Connection conn = DBConn.getConnection();   
      // Statement 3가지 종류
      // 1) Statement
      // 2) PreparedStatement
      // 3) CallableStatement - 저장 프로시저 
      Statement stmt = null;
      ResultSet rs = null;
      int empno;   
      String ename;   
      String job;   
      int mgr;   
       String hiredate;  
      double sal;
      double comm;
      int deptno;
      EmpDTO dto = null;
       
      
      try {
         stmt = conn.createStatement();
         rs = stmt.executeQuery(sql);  // select                 DQL
         
         if (rs.next()) {
        	 list = new ArrayList<>();
        	 do {
        		 empno = rs.getInt("empno");
        		 ename = rs.getString("ename");
        		 job = rs.getString("job");
        		 mgr = rs.getInt("mgr");
        		 hiredate = rs.getString("hiredate");
        		 sal = rs.getDouble("sal");
        		 comm = rs.getDouble("comm");
        		 deptno = rs.getInt("deptno");
        		 dto = new EmpDTO(empno, ename, job, mgr, hiredate, sal, comm, deptno);
        		 
        		 list.add(dto);
        	 } while (rs.next()); // while
         }
         rs.close(); // ***
      } catch (SQLException e) {
         e.printStackTrace();
      }
      DBConn.close();
      // 
      dispEmp( list );
   } // main

   private static void dispEmp(ArrayList<EmpDTO> list) {
      Iterator<EmpDTO> ir = list.iterator();
      while (ir.hasNext()) {
         EmpDTO dto =  ir.next();
         System.out.println(dto);
      }
   }
} // class
```



**Ex02**

```java
public class Ex02 {
	static Connection conn = null;
	static Scanner scanner = new Scanner(System.in);
	static int selectedNumber;
	static char _continue;

	public static void main(String[] args) {
		conn = DBConn.getConnection();

		while (true) {
			메뉴출력();
			메뉴선택();
			메뉴처리();
		}
	}

	private static void 메뉴처리() {
		switch (selectedNumber) {
		case 1: // 조회
			getAllDeptInfo();
			break;
		case 2: // 추가
			addDept();
			break;
		case 3: // 수정
			break;
		case 4: // 삭제
			break;
		case 5: // 검색
			break;
		case 6: // 종료
			exit();
			break;
		}
	}

	private static void addDept() {
		// deptno, dname, loc
		// deptno: seq_dept		60 / 10 시퀀스 생성
		System.out.println("[부서 정보 입력]");
		System.out.println("1. 부서명 입력 ? ");
		String pdname = scanner.next();
		System.out.println("2. 지역명 입력 ? ");
		String ploc = scanner.next();
		
//		String sql = "INSERT INTO dept (deptno, dname, loc) "
//				+ "VALUES (60, '" + pdname + "', 'YYY')";
		
		String sql = String.format(""
				+ "INSERT INTO dept (deptno, dname, loc) "
				+ "VALUES (seq_dept.nextval, '%s', '%s')"
				, pdname, ploc);
		
		Statement stmt = null;
		try {
			stmt = conn.createStatement();
			int rowCount = stmt.executeUpdate(sql);
			
			if (rowCount == 1) {
				System.out.println("> 1개 부서 추가 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
	}

	private static void getAllDeptInfo() {
		String sql = "SELECT * ";
		sql += "FROM dept ";
		sql += "ORDER BY deptno";

		Statement stmt = null;
		ResultSet rs = null;
		ArrayList<DeptDTO> list = null;
		DeptDTO dto = null;

		int deptno;
		String dname;
		String loc;

		try {
			stmt = conn.createStatement();
			rs = stmt.executeQuery(sql);

			if (rs.next()) {
				list = new ArrayList<>();

				do {
					deptno = rs.getInt("deptno");
					dname = rs.getString("dname");
					loc = rs.getString("loc");

					dto = new DeptDTO(deptno, dname, loc);
					list.add(dto);
				} while (rs.next());
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				rs.close();
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

		if (list == null) {
			System.out.println("> 부서 정보는 존재하지 않습니다.");
		} else {
			Iterator<DeptDTO> ir = list.iterator();

			while (ir.hasNext()) {
				dto = ir.next();
			}
		}

		일시정지();
	}

	private static void 일시정지() {
		System.out.println("\t\t 엔터치면 계속합니다.");
		try {
			System.in.read();
			System.in.skip(System.in.available());
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	private static void exit() {
		System.out.println("\t\t 프로그램 종료합니다.");
		DBConn.close();
		System.exit(-1);
	}

	private static void 메뉴선택() {
		System.out.print("> 메뉴 선택하세요 ? ");
		selectedNumber = scanner.nextInt();
	}

	private static void 메뉴출력() {
		String[] menus = {
				"부서 정보"
				, "부서 추가"
				, "부서 수정"
				, "부서 삭제"
				, "부서 검색"
				, "검색"
		};

		System.out.println("> 메뉴 출력 <");
		for (int i = 0; i < menus.length; i++) {
			System.out.printf("%d, %s\n", (i + 1), menus[i]);
		}
	}
}
```



---

Statement 3가지 종류

1. Statement
2. PreparedStatement: 성능이 가장 좋다.
3. CallableStatement: 저장 프로시저. 성능이 좋다.



```java
String sql = String.format(""
	+ "INSERT INTO dept (deptno, dname, loc) "
	+ "VALUES (seq_dept.nextval, '%s', '%s')"
	, pdname, ploc);
```

> format 이 가독성이 좋다.

**시퀀스 생성**

```sql
CREATE SEQUENCE seq_dept
INCREMENT BY 10
START WITH 60;
```



> Statement 는 자동커밋이 된다.

`conn.setAutoCommit(true)` 디폴트이다.

> SQL developer 에서 COMMIT 이 되지않아 transaction 이 걸려있다.

> String.format 을 쓸 때 문자열에 % 를 쓰려면 %% 두개를 써야된다. (LIKE)

**Ex02**

```java
public class Ex02 {
	static Connection conn = null;
	static Scanner scanner = new Scanner(System.in);
	static int selectedNumber;
	static char _continue;

	public static void main(String[] args) {
		conn = DBConn.getConnection();

		while (true) {
			메뉴출력();
			메뉴선택();
			메뉴처리();
		}
	}

	private static void 메뉴처리() {
		switch (selectedNumber) {
		case 1: // 조회
			getAllDeptInfo();
			break;
		case 2: // 추가
			addDept();
			break;
		case 3: // 수정
			editDept();
			break;
		case 4: // 삭제
			removeDept();
			break;
		case 5: // 검색
			searchDept();
			break;
		case 6: // 종료
			exit();
			break;
		}
	}

	private static void searchDept() {

		
		// 검색조건	ㄱ. 부서명 또는		ㄴ. 지역명
		System.out.println("[ 검색 조건 선택 ]");
		System.out.println(" 1. 부서명");
		System.out.println(" 2. 지역명");
		메뉴선택();
		System.out.println("> 검색어 입력 ? ");
		String searchWord = scanner.next();
		String sql = "SELECT * "
				+ "FROM dept ";
		
		if (selectedNumber == 1) { // 부서 검색
			sql += "WHERE dname LIKE '%" + searchWord + "%'"; 
		} else if (selectedNumber == 2) { // 지역명 검색
			sql += "WHERE loc LIKE '%" + searchWord + "%'";
		}
		
		Statement stmt = null;
		try {
			stmt = conn.createStatement();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		
		try {
			stmt.executeQuery(sql);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private static void removeDept() {
		System.out.print("> 삭제할 부서번호 (deptno) 입력 ? ");
		int pdeptno = scanner.nextInt();

		String sql = String.format(
				"DELETE FROM dept "
				+ "WHERE deptno = %d"
						, pdeptno);
//		System.out.println(sql);
		Statement stmt = null;
		try {
			stmt = conn.createStatement();
			int rowCount = stmt.executeUpdate(sql);

			if (rowCount == 1) {
				System.out.println("> 1개 부서 삭제 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		일시정지();

	}

	private static void editDept() {
		System.out.print("> 수정할 부서번호 (deptno) 입력 ? ");
		int pdeptno = scanner.nextInt();
		System.out.print("> 수정할 부서명 지역명을 입력 ? ");
		String pdname = scanner.next();
		String ploc = scanner.next();

		String sql = String.format("UPDATE dept SET dname = '%s', loc = '%s' WHERE deptno = %d", pdname, ploc, pdeptno);
//		System.out.println(sql);
		Statement stmt = null;
		try {
			stmt = conn.createStatement();
			int rowCount = stmt.executeUpdate(sql);

			if (rowCount == 1) {
				System.out.println("> 1개 부서 수정 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		일시정지();
	}

	private static void addDept() {
		Statement stmt = null;
		
		try {
			stmt = conn.createStatement();
		} catch (SQLException e1) {
			e1.printStackTrace();
		}
		
		do {
			System.out.println("[부서 정보 입력]");
			System.out.print("1. 부서명 입력 ? ");
			String pdname = scanner.next();
			System.out.print("2. 지역명 입력 ? ");
			String loc = scanner.next();

			String sql = String.format(
					"INSERT INTO dept (deptno, dname, loc) " 
							+ "VALUES (seq_dept.NEXTVAL, '%s', '%s')"
					, pdname, loc);
			
			try {
				int rowCount = stmt.executeUpdate(sql);
				
				if (rowCount == 1) {
					System.out.println("> 1개 행을 추가했습니다.");
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}

			
			
			계속여부확인();
		} while (Character.toUpperCase(_continue) == 'Y');



		일시정지();
	}

	private static void 계속여부확인() {
		System.out.print("> 계속 할거냐 ? ");
		try {
			_continue = (char) System.in.read();
			System.in.skip(System.in.available());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static void getAllDeptInfo() {
		String sql = "SELECT * ";
		sql += "FROM dept ";
		sql += "ORDER BY deptno";

		Statement stmt = null;
		ResultSet rs = null;
		ArrayList<DeptDTO> list = null;
		DeptDTO dto = null;

		int deptno;
		String dname;
		String loc;

		try {
			stmt = conn.createStatement();
			rs = stmt.executeQuery(sql);

			if (rs.next()) {
				list = new ArrayList<>();

				do {
					deptno = rs.getInt("deptno");
					dname = rs.getString("dname");
					loc = rs.getString("loc");

					dto = new DeptDTO(deptno, dname, loc);
					list.add(dto);
				} while (rs.next());
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				rs.close();
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

		if (list == null) {
			System.out.println("> 부서 정보는 존재하지 않습니다.");
		} else {
			Iterator<DeptDTO> ir = list.iterator();

			while (ir.hasNext()) {
				dto = ir.next();
				System.out.println(dto);
			}
		}

		일시정지();
	}

	private static void 일시정지() {
		System.out.println("\t\t 엔터치면 계속합니다.");
		try {
			System.in.read();
			System.in.skip(System.in.available());
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	private static void exit() {
		System.out.println("\t\t 프로그램 종료합니다.");
		DBConn.close();
		System.exit(-1);
	}

	private static void 메뉴선택() {
		System.out.print("> 메뉴 선택하세요 ? ");
		selectedNumber = scanner.nextInt();
	}

	private static void 메뉴출력() {
		String[] menus = { "부서 정보", "부서 추가", "부서 수정", "부서 삭제", "부서 검색", "종료" };

		System.out.println("> 메뉴 출력 <");
		for (int i = 0; i < menus.length; i++) {
			System.out.printf("%d. %s\n", (i + 1), menus[i]);
		}
	}
}
```



**[태요넷]**

columns 탭

http://taeyo.net/Columns/

ASP.net

DB 테이블 만들기
이번 게시판에서는 MS-SQL 을 사용합니다. Access나 Oracle등의 DB라면, OLE-DB 를 사용해야 하는데요, DB관련 객체가 틀리고, 소스도 약간은 수정해야 합니다. 강좌는 MS-SQL에 맞춰져 있고, OLE-DB는 따로 설명드리지 않습니다.

게시판에 사용될 테이블을 만들고 시작합니다. Query Analyser를 열어, 원하는 DB에 접속하신후 다음 SQL 구문을 실행시켜서 테이블을 만듭니다.

**MS SQL Server 테이블생성 쿼리** 

```sql
create table cstVSBoard (
  seq int identity (1, 1) not null primary key clustered, -- 글번호 (PK)
  writer varchar (20) not null , -- 작성자
  pwd varchar (20) not null , -- 비밀번호
  email varchar (100) null , -- 이메일
  title varchar (200) not null , -- 제목
  writedate smalldatetime not null default (getdate()), -- 작성일
  readed int not null default (0), -- 조회수
  mode tinyint not null , -- 0 텍스트모드 1 HTML 모드
  content text null -- 글내용
)
```

**오라클 테이블 생성쿼리**

```sql
CREATE TABLE TBL_CSTVSBOARD (
    seq NUMBER NOT NULL PRIMARY KEY, -- 글번호 (PK)
    writer VARCHAR2(20) NOT NULL , -- 작성자
    pwd VARCHAR2(20) NOT NULL , -- 비밀번호
    email VARCHAR2(100) , -- 이메일
    title VARCHAR2(200) NOT NULL , -- 제목
    writedate DATE DEFAULT sysdate, -- 작성일
    readed NUMBER DEFAULT 0, -- 조회수
    tag NUMBER(1) DEFAULT 0, -- 0 텍스트모드 1 HTML 모드
    content CLOB -- 글내용
)
```

> DEFAULT 와 NOT NULL 은 함께 쓸 수 없는 것 같다.



링크: http://taeyo.net/Columns/View.aspx?SEQ=110&PSEQ=10&IDX=1



seq(글번호) 에 사용될 시퀀스

```sql
CREATE SEQUENCE seq_tbl_cstvsBoard;
```

**[Prepared Statement]**

1. 하나의 PreparedStatement 로 쿼리를 여러 번 처리 할 수 있다.
2. DEPT 테이블 SELECT/INSERT/DELETE/UPDATE 코딩

클래스

커넥션

```java
String sql = "SELECT * "
    + "FROM dept "
    //		 + "WHERE deptno = " + pdeptno
    + "WHERE deptno = ?" // preparedStatement 의 파라미터
    + "ORDER BY deptno";
```

```sql
pstmt = conn.prepareStatement(sql);
pstmt.setInt(1, pdeptno);
rs = pstmt.executeQuery();
```



values 에 ? 를 준다. (바인딩 변수)

>  prepareStatement 에서 이미 SQL 을 가져오므로 executeQuery 의 인자가 없다.

**Ex04**

```java
public class Ex04 {
	public static void main(String[] args) {
		Connection conn = DBConn.getConnection();
		
		String sql = "SELECT * ";
		sql += "FROM dept ";
		sql += "ORDER BY deptno";

		PreparedStatement pstmt = null;
		ResultSet rs = null;
		ArrayList<DeptDTO> list = null;
		DeptDTO dto = null;

		int deptno;
		String dname;
		String loc;

		try {
//			stmt = conn.createStatement();
			pstmt = conn.prepareStatement(sql);
			rs = pstmt.executeQuery();
			

			if (rs.next()) {
				list = new ArrayList<>();

				do {
					deptno = rs.getInt("deptno");
					dname = rs.getString("dname");
					loc = rs.getString("loc");

					dto = new DeptDTO(deptno, dname, loc);
					list.add(dto);
				} while (rs.next());
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				rs.close();
				pstmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

		if (list == null) {
			System.out.println("> 부서 정보는 존재하지 않습니다.");
		} else {
			Iterator<DeptDTO> ir = list.iterator();

			while (ir.hasNext()) {
				dto = ir.next();
				System.out.println(dto);
			}
		}

		DBConn.close();

	}

}
```

**[PreparedStatement] Dept 테이블에 UPDATE**

```java
public class Ex04_04 {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		Connection conn = DBConn.getConnection();
		
		System.out.print("> 수정할 부서번호 (deptno) 입력 ? ");
		int pdeptno = scanner.nextInt();
		System.out.print("> 수정할 부서명 지역명을 입력 ? ");
		String pdname = scanner.next();
		String ploc = scanner.next();

		String sql = 
				"UPDATE dept "
				+ "SET dname = ?, loc = ? "
				+ "WHERE deptno = ?";
//		System.out.println(sql);
		PreparedStatement pstmt = null;
		try {
			pstmt = conn.prepareStatement(sql);
			pstmt.setString(1, pdname);
			pstmt.setString(2, ploc);
			pstmt.setInt(3, pdeptno);
			int rowCount = pstmt.executeUpdate();

			if (rowCount == 1) {
				System.out.println("> 1개 부서 수정 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				pstmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}	
	}
}
```

**순서**

SQL -> Connection -> Statement -> Execute -> Statement close

**DELETE** 

```java
public class Ex04_05 {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		Connection conn = DBConn.getConnection();
		
		System.out.print("> 삭제할 부서번호 (deptno) 입력 ? ");
		int pdeptno = scanner.nextInt();

		String sql = 
				"DELETE FROM dept " + "WHERE deptno = ?";
		PreparedStatement pstmt = null;
		
		try {
			pstmt = conn.prepareStatement(sql);
			pstmt.setInt(1, pdeptno);
			int rowCount = pstmt.executeUpdate();

			if (rowCount == 1) {
				System.out.println("> 1개 부서 삭제 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				pstmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
}
```

공부: Cassatt 의 VS.NET 게시판 강좌 한번 읽어보기

