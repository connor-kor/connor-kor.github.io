---
title: 강의9
category: fullstack-class
---

# 11.15

**[동적 SQL] 필요성**

1. 컴파일 시에 SQL 문장이 확정이 되지 않은 경우. WHERE 조건절, SELECT 항목이 동적으로 변하는 경우
2. PL/SQL 블록 상에서 DDL 문을 실행해야 하는 경우 (CREATE, ATLER, DROP, TRUNCATE 문)
3. PL/SQL 블록 상에서 ALTER 

동적 SQL 을 사용하는 방법

1. 원시 동적 SQL (Native Dynamic SQL: NDS) +++
2. dbms_sql 패키지 사용

동적 SQL 을 실행할 때

```sql
EXECUTE 프로시저명;
```

**형식**

```sql
EXECUTE IMMEDIATE 동적SQL문
[INTO 변수...]
[USING 모드(IN OUT INOUT) 파라미터...]
```

예)

**익명프로시저**

```
20, 7369, SMITH, CLERK
```



```sql
-- ㄱ. 익명프로시저
DECLARE
    vsql VARCHAR2(1000); -- 동적 SQL 을 저장할 변수 선언
    vdeptno emp.deptno%TYPE;
    vempno emp.empno%TYPE;
    vename emp.ename%TYPE;
    Vjob emp.job%TYPE;
BEGIN
    -- 동적 SQL 작성
    vsql := 'SELECT deptno, empno, ename, job ';
    vsql := vsql || 'FROM emp ';
    vsql := vsql || 'WHERE empno = 7369';
    
    -- 동적 SQL 실행
    EXECUTE IMMEDIATE vsql
    INTO vdeptno, vempno, vename, vjob;
    
    dbms_output.put_line(vdeptno || ', ' || vempno || ', ' || vename || ', ' || vjob);
END;
```

> vsql 사이에 띄어쓰기를 꼭 할 것!!

**저장프로시저**

```sql
-- ㄴ. 저장 프로시저
CREATE OR REPLACE PROCEDURE up_nds01 (
    pempno emp.empno%TYPE
)
IS
    vsql VARCHAR2(1000); -- 동적 SQL 을 저장할 변수 선언
    vdeptno emp.deptno%TYPE;
    vempno emp.empno%TYPE;
    vename emp.ename%TYPE;
    Vjob emp.job%TYPE;
BEGIN
    -- 동적 SQL 작성
    vsql := 'SELECT deptno, empno, ename, job ';
    vsql := vsql || 'FROM emp ';
    vsql := vsql || 'WHERE empno = :pempno';
    
    -- 동적 SQL 실행
    EXECUTE IMMEDIATE vsql
    INTO vdeptno, vempno, vename, vjob
    USING pempno;
    
    dbms_output.put_line(vdeptno || ', ' || vempno || ', ' || vename || ', ' || vjob);
END;
```



**dept 테이블에 INSERT 를 수행하는 동적 SQL**

```sql
CREATE OR REPLACE PROCEDURE up_insdept (
    pdname dept.dname%TYPE
    , ploc dept.loc%TYPE
)
IS  
    vsql    VARCHAR2(1000);
    vdeptno dept.deptno%TYPE;
BEGIN
    SELECT max(deptno) + 10 INTO vdeptno
    FROM dept;
    
    vsql := 'INSERT INTO dept ';
    vsql := vsql || 'VALUES (:deptno, :dname, :loc) ';
    
    EXECUTE IMMEDIATE vsql
    USING vdeptno, pdname, ploc;
END;
```

```
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	CHICAGO
40	OPERATIONS	BOSTON
50	QC	
```



```sql
EXEC up_insdept('A', 'B');
```

**테이블 만들기**

```sql
DECLARE 
    vsql VARCHAR2(1000);
BEGIN
    vsql := 'CREATE TABLE tbl_nds (id number, name varchar2(1000))';
    EXECUTE IMMEDIATE vsql;
END;
```

```sql
OPEN 커서명 FOR vsql USING pdeptno;
```

예제

```sql
CREATE OR REPLACE PROCEDURE up_nds02 (
    pdeptno emp.deptno%TYPE
)
IS
    vsql VARCHAR2(1000);
    vCursor SYS_REFCURSOR;
    vrow emp%ROWTYPE;
BEGIN 
    vsql := 'SELECT * ';
    vsql := vsql || 'FROM emp ';
    vsql := vsql || 'WHERE deptno = :deptno ';
    
--    EXECUTE IMMEDIATE vsql USING pdeptno; X 
    OPEN vCursor FOR vsql USING pdeptno;
    LOOP
        FETCH vCursor INTO vrow;
        EXIT WHEN vCursor%NOTFOUND;
        dbms_output.put_line(vrow.ename || ', ' || vrow.job);
    END LOOP;
    CLOSE vCursor;
END;
```

```sql
EXEC up_nds02(30);
```

# 11.16

JavaSE-1.8 뜨게하기

[용어정리]

1. JDBC 란 ?
2. JDBC Driver 란 ?
3. JDBC Driver 의 종류
4. Java + Oracle 연동방법

[JDBC ]

Java DataBase Connectivity 

자바표준 인터페이스

JDBC Driver

Oracle 11g XE

Oracle JDBC Driver == ojdbc6.jar



**설정**

관리도구 - ODBC 데이터 원본(64비트)



(6) Connection 클래스 - J + 연결 + O

1. Class.forName() JDBC Driver (ojdbc6.jar) 로딩
2. DriverManager 클래스 . getConnection() 메서드 -> Connection 객체를 얻어온다.
3. SQL + PL/SQL 질의/응답 작업
4. 연결종료 (Close)

(7) Connection 의 속성

어떤 DB 서버 ? DatabaseName (SID: XE)

계정 ? scott

비밀번호 ? tiger



**JDBC 연동**

ojdbc6.jar 파일을 연결해야 자바 프로젝트를 인식할 수 있다.



프로젝트 우클릭 - Build Path - Configure Build Path

Libraries 탭 -  Add External Jars 로 ojdbc6.jar 선택

```java
String className = "oracle.jdbc.driver.OracleDriver";
String url = "jdbc:oracle:thin:@localhost:1521:xe";
String user = "scott";
String password = "tiger";
Connection conn = null;

try {
    Class.forName(className);
    conn = DriverManager.getConnection(url, user, password);

    System.out.println(conn);
} catch (ClassNotFoundException e) {
    e.printStackTrace();
} catch (SQLException e) {
    e.printStackTrace();
} finally {
    try {
        if (conn != null && !conn.isClosed()) {
            conn.close();
        }
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```



**숏코딩**

```
oracle.jdbc.driver.T4CConnection@60611244
```



```java
String className = "oracle.jdbc.driver.OracleDriver";
String url = "jdbc:oracle:thin:@localhost:1521:xe";
String user = "scott";
String password = "tiger";

Class.forName(className);
Connection conn = DriverManager.getConnection(url, user, password);
```

연결닫기

**DBConn**

```java
public class DBConn {
   private DBConn(){}
   private static Connection connection = null;
   
   public static Connection getConnection() {
      if( connection == null ) { 
         String className = "oracle.jdbc.driver.OracleDriver";
         String url = "jdbc:oracle:thin:@localhost:1521:xe";
         String user = "scott";
         String password = "tiger";         
         try {
            Class.forName(className); 
            connection = DriverManager.getConnection(url, user, password);
         } catch (ClassNotFoundException e) { 
            e.printStackTrace();
         } catch (SQLException e) {
            e.printStackTrace();
         } 
      } // if
      return connection;
   }  // getConnection
   
   public static Connection getConnection(String url, String user, String password) {
	   if( connection == null ) { 
		   String className = "oracle.jdbc.driver.OracleDriver";
		   try {
			   Class.forName(className); 
			   connection = DriverManager.getConnection(url, user, password);
		   } catch (ClassNotFoundException e) { 
			   e.printStackTrace();
		   } catch (SQLException e) {
			   e.printStackTrace();
		   } 
	   } // if
	   return connection;
   }  // getConnection
   
   public static Connection getConnection(String serverName, int port, String sid, String user, String password) {
	   if( connection == null ) { 
		   String className = "oracle.jdbc.driver.OracleDriver";
			String url = String.format("jdbc:oracle:thin:@%s:%d:%s", serverName, port, sid);

		   try {
			   Class.forName(className); 
			   connection = DriverManager.getConnection(url, user, password);
		   } catch (ClassNotFoundException e) { 
			   e.printStackTrace();
		   } catch (SQLException e) {
			   e.printStackTrace();
		   } 
	   } // if
	   return connection;
   }  // getConnection

   public static void close() {
      try { 
         if ( connection != null && !connection.isClosed() ) {
            connection.close();
         }
      } catch (SQLException e) { 
         e.printStackTrace();
      }
      connection = null; // ***
   }
} // class
```

(3) 필요한 작업 - Statement, ResultSet

`Statement` java.beans 가 아니라 java.sql 을 사용한다.

**Connection conn.**

- `createStatement` 

**Statement state.**

- `executeQuery` SELECT
- `executeUpdate()` INSERT, UPDATE, DELETE 

**ResultSet rs.**

- `next()` boolean 을 반환.



```java
// 1 + 2
Connection conn = DBConn.getConnection();

// 3. 필요한 작업 - Statement, ResultSet
String sql = "SELECT * FROM dept"; // DQL(SELECT)
String dname, loc; 

try {
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(sql);

    if (rs.next()) {
        int deptno = rs.getInt(1);
        System.out.printf("%d\n", deptno);
    }

    rs.close(); // 꼭 닫자. ***
} catch (SQLException e) {
    e.printStackTrace();
}

// 4
DBConn.close();
System.out.println("END");
```

# 11.17

**복습**

1-1. 동적 쿼리를 사용하는 저장 프로시저 작성하세요. 
ㄱ. 커서변수 사용
ㄴ. open ~ for 문 사용
ㄷ. 프로시저 안에서  출력까지 하세요.
ㄹ. deptno 를 파라미터로 해서 emp 테이블의
    deptno, ename, hiredate 를 출력하는 
    저장 프로시저 작성.

```sql
CREATE OR REPLACE PROCEDURE sel_emp (
    pdeptno NUMBER
)
IS
    vsql VARCHAR2(1000);
    vdeptno NUMBER(5);
    vename VARCHAR2(50);
    vhiredate DATE;
    vCursor SYS_REFCURSOR;
BEGIN
    vsql := 'SELECT deptno, ename, hiredate FROM emp WHERE deptno = :pdeptno';
    
    OPEN vCursor FOR vsql USING pdeptno;
    LOOP
        FETCH vCursor INTO vdeptno, vename, vhiredate;
        EXIT WHEN vCursor%NOTFOUND;
        
        dbms_output.put_line(vdeptno || ' ' || vename || ' ' || vhiredate);
    END LOOP;
END;
```

ㄱ. JDBC - 자바 표준 인터페이스

ㄴ. Oracle JDBC Driver : ojdbc6.jar + jdbcPro 라이브러리 추가 (참조)

com.util.DBConn 싱글톤 클래스 - getConnection(), close()

ㄷ. JDBC Driver 로딩 : Class.forName()

ㄹ. Connection 객체 : DriverManager.getConnection() 3개 오버로딩

ㅁ. 질의 (SQL) / 응답

ㅂ. 닫기 (close)



5-1. 부서번호를 입력받아서 해당 부서의 모든 사원 정보를 출력 
( 조건 :
ㄱ. 모든 컬럼 출력
ㄴ. 이름 순으로 오름차순정렬
ㄷ. ArrayList 에 부서원 정보 저장
ㄹ. dispEmp( ArrayList list) 출력 메서드 만들어서 정보 출력.
   )      



> DBConn 은 꼭 사용 후 닫을 것!!



```java
public class Ex01 {
   public static void main(String[] args) {
      // 1. EmpDTO/EmpVO 클래스 선언
      ArrayList<EmpDTO> list = null;
      
      // ㄱ. JDBC - 자바 표준 인터페이스
      // ㄴ. Oracle JDBC Driver : ojdbc6.jar + jdbcPro 라이브러리 추가(참조)
      
      // com.util.DBConn 싱글톤 클래스  - getConnection(), close()
//       ㄷ. JDBC Driver 로딩   : Class.forName()
//       ㄹ. Connection 객체    : DriverManager.getConnection() 3개 오버로딩
//       ㅁ. 질의(SQL)/응답
//       ㅂ. 닫기( close ) 
      
      int pdeptno ;
      System.out.print("> 부서번호(deptno) 입력 ? ");
      Scanner scanner =  new Scanner(System.in);
      pdeptno = scanner.nextInt();
      
      String sql  = "SELECT * ";
            sql += "FROM emp ";
            sql += "WHERE deptno =  " + pdeptno ;
            sql += "ORDER BY ename ASC";
      // 
      Connection conn = DBConn.getConnection();   
      // Statement 3가지 종류
      // 1) Statement
      // 2) PreparedStatement
      // 3) CallableStatement - 저장 프로시저 
      Statement stmt = null;
      ResultSet rs = null;
      int empno;   
      String ename;   
      String job;   
      int mgr;   
       String hiredate;  
      double sal;
      double comm;
      int deptno;
      EmpDTO dto = null;
       
      
      try {
         stmt = conn.createStatement();
         rs = stmt.executeQuery(sql);  // select                 DQL
         
         if (rs.next()) {
        	 list = new ArrayList<>();
        	 do {
        		 empno = rs.getInt("empno");
        		 ename = rs.getString("ename");
        		 job = rs.getString("job");
        		 mgr = rs.getInt("mgr");
        		 hiredate = rs.getString("hiredate");
        		 sal = rs.getDouble("sal");
        		 comm = rs.getDouble("comm");
        		 deptno = rs.getInt("deptno");
        		 dto = new EmpDTO(empno, ename, job, mgr, hiredate, sal, comm, deptno);
        		 
        		 list.add(dto);
        	 } while (rs.next()); // while
         }
         rs.close(); // ***
      } catch (SQLException e) {
         e.printStackTrace();
      }
      DBConn.close();
      // 
      dispEmp( list );
   } // main

   private static void dispEmp(ArrayList<EmpDTO> list) {
      Iterator<EmpDTO> ir = list.iterator();
      while (ir.hasNext()) {
         EmpDTO dto =  ir.next();
         System.out.println(dto);
      }
   }
} // class
```



**Ex02**

```java
public class Ex02 {
	static Connection conn = null;
	static Scanner scanner = new Scanner(System.in);
	static int selectedNumber;
	static char _continue;

	public static void main(String[] args) {
		conn = DBConn.getConnection();

		while (true) {
			메뉴출력();
			메뉴선택();
			메뉴처리();
		}
	}

	private static void 메뉴처리() {
		switch (selectedNumber) {
		case 1: // 조회
			getAllDeptInfo();
			break;
		case 2: // 추가
			addDept();
			break;
		case 3: // 수정
			break;
		case 4: // 삭제
			break;
		case 5: // 검색
			break;
		case 6: // 종료
			exit();
			break;
		}
	}

	private static void addDept() {
		// deptno, dname, loc
		// deptno: seq_dept		60 / 10 시퀀스 생성
		System.out.println("[부서 정보 입력]");
		System.out.println("1. 부서명 입력 ? ");
		String pdname = scanner.next();
		System.out.println("2. 지역명 입력 ? ");
		String ploc = scanner.next();
		
//		String sql = "INSERT INTO dept (deptno, dname, loc) "
//				+ "VALUES (60, '" + pdname + "', 'YYY')";
		
		String sql = String.format(""
				+ "INSERT INTO dept (deptno, dname, loc) "
				+ "VALUES (seq_dept.nextval, '%s', '%s')"
				, pdname, ploc);
		
		Statement stmt = null;
		try {
			stmt = conn.createStatement();
			int rowCount = stmt.executeUpdate(sql);
			
			if (rowCount == 1) {
				System.out.println("> 1개 부서 추가 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
	}

	private static void getAllDeptInfo() {
		String sql = "SELECT * ";
		sql += "FROM dept ";
		sql += "ORDER BY deptno";

		Statement stmt = null;
		ResultSet rs = null;
		ArrayList<DeptDTO> list = null;
		DeptDTO dto = null;

		int deptno;
		String dname;
		String loc;

		try {
			stmt = conn.createStatement();
			rs = stmt.executeQuery(sql);

			if (rs.next()) {
				list = new ArrayList<>();

				do {
					deptno = rs.getInt("deptno");
					dname = rs.getString("dname");
					loc = rs.getString("loc");

					dto = new DeptDTO(deptno, dname, loc);
					list.add(dto);
				} while (rs.next());
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				rs.close();
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

		if (list == null) {
			System.out.println("> 부서 정보는 존재하지 않습니다.");
		} else {
			Iterator<DeptDTO> ir = list.iterator();

			while (ir.hasNext()) {
				dto = ir.next();
			}
		}

		일시정지();
	}

	private static void 일시정지() {
		System.out.println("\t\t 엔터치면 계속합니다.");
		try {
			System.in.read();
			System.in.skip(System.in.available());
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	private static void exit() {
		System.out.println("\t\t 프로그램 종료합니다.");
		DBConn.close();
		System.exit(-1);
	}

	private static void 메뉴선택() {
		System.out.print("> 메뉴 선택하세요 ? ");
		selectedNumber = scanner.nextInt();
	}

	private static void 메뉴출력() {
		String[] menus = {
				"부서 정보"
				, "부서 추가"
				, "부서 수정"
				, "부서 삭제"
				, "부서 검색"
				, "검색"
		};

		System.out.println("> 메뉴 출력 <");
		for (int i = 0; i < menus.length; i++) {
			System.out.printf("%d, %s\n", (i + 1), menus[i]);
		}
	}
}
```



---

Statement 3가지 종류

1. Statement
2. PreparedStatement: 성능이 가장 좋다.
3. CallableStatement: 저장 프로시저. 성능이 좋다.



```java
String sql = String.format(""
	+ "INSERT INTO dept (deptno, dname, loc) "
	+ "VALUES (seq_dept.nextval, '%s', '%s')"
	, pdname, ploc);
```

> format 이 가독성이 좋다.

**시퀀스 생성**

```sql
CREATE SEQUENCE seq_dept
INCREMENT BY 10
START WITH 60;
```



> Statement 는 자동커밋이 된다.

`conn.setAutoCommit(true)` 디폴트이다.

> SQL developer 에서 COMMIT 이 되지않아 transaction 이 걸려있다.

> String.format 을 쓸 때 문자열에 % 를 쓰려면 %% 두개를 써야된다. (LIKE)

**Ex02**

```java
public class Ex02 {
	static Connection conn = null;
	static Scanner scanner = new Scanner(System.in);
	static int selectedNumber;
	static char _continue;

	public static void main(String[] args) {
		conn = DBConn.getConnection();

		while (true) {
			메뉴출력();
			메뉴선택();
			메뉴처리();
		}
	}

	private static void 메뉴처리() {
		switch (selectedNumber) {
		case 1: // 조회
			getAllDeptInfo();
			break;
		case 2: // 추가
			addDept();
			break;
		case 3: // 수정
			editDept();
			break;
		case 4: // 삭제
			removeDept();
			break;
		case 5: // 검색
			searchDept();
			break;
		case 6: // 종료
			exit();
			break;
		}
	}

	private static void searchDept() {

		
		// 검색조건	ㄱ. 부서명 또는		ㄴ. 지역명
		System.out.println("[ 검색 조건 선택 ]");
		System.out.println(" 1. 부서명");
		System.out.println(" 2. 지역명");
		메뉴선택();
		System.out.println("> 검색어 입력 ? ");
		String searchWord = scanner.next();
		String sql = "SELECT * "
				+ "FROM dept ";
		
		if (selectedNumber == 1) { // 부서 검색
			sql += "WHERE dname LIKE '%" + searchWord + "%'"; 
		} else if (selectedNumber == 2) { // 지역명 검색
			sql += "WHERE loc LIKE '%" + searchWord + "%'";
		}
		
		Statement stmt = null;
		try {
			stmt = conn.createStatement();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		
		try {
			stmt.executeQuery(sql);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	private static void removeDept() {
		System.out.print("> 삭제할 부서번호 (deptno) 입력 ? ");
		int pdeptno = scanner.nextInt();

		String sql = String.format(
				"DELETE FROM dept "
				+ "WHERE deptno = %d"
						, pdeptno);
//		System.out.println(sql);
		Statement stmt = null;
		try {
			stmt = conn.createStatement();
			int rowCount = stmt.executeUpdate(sql);

			if (rowCount == 1) {
				System.out.println("> 1개 부서 삭제 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		일시정지();

	}

	private static void editDept() {
		System.out.print("> 수정할 부서번호 (deptno) 입력 ? ");
		int pdeptno = scanner.nextInt();
		System.out.print("> 수정할 부서명 지역명을 입력 ? ");
		String pdname = scanner.next();
		String ploc = scanner.next();

		String sql = String.format("UPDATE dept SET dname = '%s', loc = '%s' WHERE deptno = %d", pdname, ploc, pdeptno);
//		System.out.println(sql);
		Statement stmt = null;
		try {
			stmt = conn.createStatement();
			int rowCount = stmt.executeUpdate(sql);

			if (rowCount == 1) {
				System.out.println("> 1개 부서 수정 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		일시정지();
	}

	private static void addDept() {
		Statement stmt = null;
		
		try {
			stmt = conn.createStatement();
		} catch (SQLException e1) {
			e1.printStackTrace();
		}
		
		do {
			System.out.println("[부서 정보 입력]");
			System.out.print("1. 부서명 입력 ? ");
			String pdname = scanner.next();
			System.out.print("2. 지역명 입력 ? ");
			String loc = scanner.next();

			String sql = String.format(
					"INSERT INTO dept (deptno, dname, loc) " 
							+ "VALUES (seq_dept.NEXTVAL, '%s', '%s')"
					, pdname, loc);
			
			try {
				int rowCount = stmt.executeUpdate(sql);
				
				if (rowCount == 1) {
					System.out.println("> 1개 행을 추가했습니다.");
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}

			
			
			계속여부확인();
		} while (Character.toUpperCase(_continue) == 'Y');



		일시정지();
	}

	private static void 계속여부확인() {
		System.out.print("> 계속 할거냐 ? ");
		try {
			_continue = (char) System.in.read();
			System.in.skip(System.in.available());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static void getAllDeptInfo() {
		String sql = "SELECT * ";
		sql += "FROM dept ";
		sql += "ORDER BY deptno";

		Statement stmt = null;
		ResultSet rs = null;
		ArrayList<DeptDTO> list = null;
		DeptDTO dto = null;

		int deptno;
		String dname;
		String loc;

		try {
			stmt = conn.createStatement();
			rs = stmt.executeQuery(sql);

			if (rs.next()) {
				list = new ArrayList<>();

				do {
					deptno = rs.getInt("deptno");
					dname = rs.getString("dname");
					loc = rs.getString("loc");

					dto = new DeptDTO(deptno, dname, loc);
					list.add(dto);
				} while (rs.next());
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				rs.close();
				stmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

		if (list == null) {
			System.out.println("> 부서 정보는 존재하지 않습니다.");
		} else {
			Iterator<DeptDTO> ir = list.iterator();

			while (ir.hasNext()) {
				dto = ir.next();
				System.out.println(dto);
			}
		}

		일시정지();
	}

	private static void 일시정지() {
		System.out.println("\t\t 엔터치면 계속합니다.");
		try {
			System.in.read();
			System.in.skip(System.in.available());
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	private static void exit() {
		System.out.println("\t\t 프로그램 종료합니다.");
		DBConn.close();
		System.exit(-1);
	}

	private static void 메뉴선택() {
		System.out.print("> 메뉴 선택하세요 ? ");
		selectedNumber = scanner.nextInt();
	}

	private static void 메뉴출력() {
		String[] menus = { "부서 정보", "부서 추가", "부서 수정", "부서 삭제", "부서 검색", "종료" };

		System.out.println("> 메뉴 출력 <");
		for (int i = 0; i < menus.length; i++) {
			System.out.printf("%d. %s\n", (i + 1), menus[i]);
		}
	}
}
```



**[태요넷]**

columns 탭

http://taeyo.net/Columns/

ASP.net

DB 테이블 만들기
이번 게시판에서는 MS-SQL 을 사용합니다. Access나 Oracle등의 DB라면, OLE-DB 를 사용해야 하는데요, DB관련 객체가 틀리고, 소스도 약간은 수정해야 합니다. 강좌는 MS-SQL에 맞춰져 있고, OLE-DB는 따로 설명드리지 않습니다.

게시판에 사용될 테이블을 만들고 시작합니다. Query Analyser를 열어, 원하는 DB에 접속하신후 다음 SQL 구문을 실행시켜서 테이블을 만듭니다.

**MS SQL Server 테이블생성 쿼리** 

```sql
create table cstVSBoard (
  seq int identity (1, 1) not null primary key clustered, -- 글번호 (PK)
  writer varchar (20) not null , -- 작성자
  pwd varchar (20) not null , -- 비밀번호
  email varchar (100) null , -- 이메일
  title varchar (200) not null , -- 제목
  writedate smalldatetime not null default (getdate()), -- 작성일
  readed int not null default (0), -- 조회수
  mode tinyint not null , -- 0 텍스트모드 1 HTML 모드
  content text null -- 글내용
)
```

**오라클 테이블 생성쿼리**

```sql
CREATE TABLE TBL_CSTVSBOARD (
    seq NUMBER NOT NULL PRIMARY KEY, -- 글번호 (PK)
    writer VARCHAR2(20) NOT NULL , -- 작성자
    pwd VARCHAR2(20) NOT NULL , -- 비밀번호
    email VARCHAR2(100) , -- 이메일
    title VARCHAR2(200) NOT NULL , -- 제목
    writedate DATE DEFAULT sysdate, -- 작성일
    readed NUMBER DEFAULT 0, -- 조회수
    tag NUMBER(1) DEFAULT 0, -- 0 텍스트모드 1 HTML 모드
    content CLOB -- 글내용
)
```

> DEFAULT 와 NOT NULL 은 함께 쓸 수 없는 것 같다.



링크: http://taeyo.net/Columns/View.aspx?SEQ=110&PSEQ=10&IDX=1



seq(글번호) 에 사용될 시퀀스

```sql
CREATE SEQUENCE seq_tbl_cstvsBoard;
```

**[Prepared Statement]**

1. 하나의 PreparedStatement 로 쿼리를 여러 번 처리 할 수 있다.
2. DEPT 테이블 SELECT/INSERT/DELETE/UPDATE 코딩

클래스

커넥션

```java
String sql = "SELECT * "
    + "FROM dept "
    //		 + "WHERE deptno = " + pdeptno
    + "WHERE deptno = ?" // preparedStatement 의 파라미터
    + "ORDER BY deptno";
```

```sql
pstmt = conn.prepareStatement(sql);
pstmt.setInt(1, pdeptno);
rs = pstmt.executeQuery();
```



values 에 ? 를 준다. (바인딩 변수)

>  prepareStatement 에서 이미 SQL 을 가져오므로 executeQuery 의 인자가 없다.

**Ex04**

```java
public class Ex04 {
	public static void main(String[] args) {
		Connection conn = DBConn.getConnection();
		
		String sql = "SELECT * ";
		sql += "FROM dept ";
		sql += "ORDER BY deptno";

		PreparedStatement pstmt = null;
		ResultSet rs = null;
		ArrayList<DeptDTO> list = null;
		DeptDTO dto = null;

		int deptno;
		String dname;
		String loc;

		try {
//			stmt = conn.createStatement();
			pstmt = conn.prepareStatement(sql);
			rs = pstmt.executeQuery();
			

			if (rs.next()) {
				list = new ArrayList<>();

				do {
					deptno = rs.getInt("deptno");
					dname = rs.getString("dname");
					loc = rs.getString("loc");

					dto = new DeptDTO(deptno, dname, loc);
					list.add(dto);
				} while (rs.next());
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				rs.close();
				pstmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

		if (list == null) {
			System.out.println("> 부서 정보는 존재하지 않습니다.");
		} else {
			Iterator<DeptDTO> ir = list.iterator();

			while (ir.hasNext()) {
				dto = ir.next();
				System.out.println(dto);
			}
		}

		DBConn.close();

	}

}
```

**[PreparedStatement] Dept 테이블에 UPDATE**

```java
public class Ex04_04 {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		Connection conn = DBConn.getConnection();
		
		System.out.print("> 수정할 부서번호 (deptno) 입력 ? ");
		int pdeptno = scanner.nextInt();
		System.out.print("> 수정할 부서명 지역명을 입력 ? ");
		String pdname = scanner.next();
		String ploc = scanner.next();

		String sql = 
				"UPDATE dept "
				+ "SET dname = ?, loc = ? "
				+ "WHERE deptno = ?";
//		System.out.println(sql);
		PreparedStatement pstmt = null;
		try {
			pstmt = conn.prepareStatement(sql);
			pstmt.setString(1, pdname);
			pstmt.setString(2, ploc);
			pstmt.setInt(3, pdeptno);
			int rowCount = pstmt.executeUpdate();

			if (rowCount == 1) {
				System.out.println("> 1개 부서 수정 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				pstmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}	
	}
}
```

**순서**

SQL -> Connection -> Statement -> Execute -> Statement close

**DELETE** 

```java
public class Ex04_05 {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		Connection conn = DBConn.getConnection();
		
		System.out.print("> 삭제할 부서번호 (deptno) 입력 ? ");
		int pdeptno = scanner.nextInt();

		String sql = 
				"DELETE FROM dept " + "WHERE deptno = ?";
		PreparedStatement pstmt = null;
		
		try {
			pstmt = conn.prepareStatement(sql);
			pstmt.setInt(1, pdeptno);
			int rowCount = pstmt.executeUpdate();

			if (rowCount == 1) {
				System.out.println("> 1개 부서 삭제 완료!!!");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				pstmt.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
}
```

공부: Cassatt 의 VS.NET 게시판 강좌 한번 읽어보기

# 11.18

**복습**

1-1. ConnectionString.properties 파일을 Properties 컬렉션을 사용해서 
hostname, sid, user, password 속성값을 읽어서  DB 연동해서 
HR의 departments 테이블의 부서 정보를 출력하는 코딩을 하세요.
ㄱ. PreparedStatement 사용.
ㄴ. ArrayList`<DepartmentDTO>` list  사용.
ㄷ. manager_id 가 NULL 인  부서 정보만 출력.

```java
Properties prop = new Properties();
prop.load(new FileReader("C:\\class\\JDBCClass\\jdbcPro\\src\\com\\util\\ConnectionString.properties"));
String hostname = prop.getProperty("hostname");
String password = prop.getProperty("password");
String user = prop.getProperty("user");
String sid = prop.getProperty("sid");
int port = 1521;
Connection conn = DBConn.getConnection(hostname, port, sid, user, password);
String sql = 
    "SELECT * "
    + "FROM departments "
    + "WHERE manager_id IS NULL";

PreparedStatement pre = conn.prepareStatement(sql);
ResultSet rs = pre.executeQuery();

ArrayList<DepartmentDTO> list = new ArrayList<>();

while (rs.next()) {
    DepartmentDTO dto = new DepartmentDTO(
        rs.getInt("department_id")
        , rs.getInt("manager_id")
        , rs.getInt("location_id")
        , rs.getString("department_name"));
    list.add(dto);
}

for (DepartmentDTO dto : list) System.out.println(dto);
```

> `System.getProperty("user.dir")` 를 사용하는게 더 좋은 코딩이다.

2-1. HR의 departments 테이블의 레코드 삭제하는 코딩을 하세요.  
ㄱ. department_id 가 140 인 부서 삭제
ㄴ. PreparedStatement 사용

```java
Properties prop = new Properties();
prop.load(new FileReader("C:\\class\\JDBCClass\\jdbcPro\\src\\com\\util\\ConnectionString.properties"));
String hostname = prop.getProperty("hostname");
String password = prop.getProperty("password");
String user = prop.getProperty("user");
String sid = prop.getProperty("sid");
int port = 1521;
Connection conn = DBConn.getConnection(hostname, port, sid, user, password);

String delSql = 
    "DELETE FROM departments "
    + "WHERE department_id = 140 ";

PreparedStatement pre = conn.prepareStatement(delSql);
int rowCount = pre.executeUpdate();

System.out.printf("%d 개 레코드를 삭제했습니다.", rowCount);
```



3-1. HR의 departments 테이블의 레코드 추가하는 코딩을 하세요.  
ㄱ. PreparedStatement 사용   
ㄴ. 조금 전 삭제한 department_id 가 140 인 부서 추가 
ㄷ. 추가할 컬럼값.
DEPARTMENT_ID DEPARTMENT_NAME                MANAGER_ID LOCATION_ID

```
DEPARTMENT_ID DEPARTMENT_NAME MANAGER_ID  LOCATION_ID
------------------------------------------------------
140         Control And Credit   (null)       1700
```





```java
Properties prop = new Properties();
prop.load(new FileReader("C:\\class\\JDBCClass\\jdbcPro\\src\\com\\util\\ConnectionString.properties"));
String hostname = prop.getProperty("hostname");
String password = prop.getProperty("password");
String user = prop.getProperty("user");
String sid = prop.getProperty("sid");
int port = 1521;
Connection conn = DBConn.getConnection(hostname, port, sid, user, password);
String InsSql = 
    "INSERT INTO departments (department_id, department_name, location_id)"
    + "VALUES (?, ?, ?)";

int department_id = 140;
String department_name = "Control And Credit";
int location_id = 1700;

PreparedStatement pre = conn.prepareStatement(InsSql);
pre.setInt(1, department_id);
pre.setString(2, department_name);
pre.setInt(3, location_id);

int rowCount = pre.executeUpdate();

System.out.printf("%d 개 레코드를 추가했습니다.", rowCount);
```



**regexp_like**

```java
public class Ex02_02 {
   
   static Connection conn = null;
   static int selectedNumber;
   static Scanner scanner = new Scanner(System.in);
   
   private static void 메뉴선택() {
      System.out.print("> 메뉴 선택하세요 ? ");
      selectedNumber = scanner.nextInt();      
   }

   public static void main(String[] args) {
      // [ PreparedStatement ]  Dept 테이블에 검색
      // 검색조건   ㄱ. 부서명 또는 ㄴ. 지역명
      
       conn = DBConn.getConnection();

      System.out.println("[ 검색 조건 선택]");
      System.out.println("  1. 부서명 ");
      System.out.println("  2. 지역명 ");
      메뉴선택();  // selectedNumber   1 or 2
      System.out.print("> 검색어 입력 ? ");
      String searchWord = scanner.next();
      
      String sql = "SELECT * FROM dept ";
      if ( selectedNumber == 1) {  // 부서명 검색          
         sql += " WHERE regexp_like(dname, ?, i) "; // ***** 컬럼명(dname)을  ? 로 사용 못 한다. 
         //sql += String.format(" WHERE dname LIKE '%%%s%%'", searchWord);

         // REGEXP_LIKE() 수정
         //sql += String.format(" WHERE REGEXP_LIKE( dname , '%s', 'i')", searchWord);
      } else if( selectedNumber == 2){ // 지역명 검색         
         sql += " WHERE loc LIKE ? ";
      }
      // System.out.println( sql );

      // getAllDeptInfo() 코딩 복사 수정.... 

      PreparedStatement  pstmt = null;
      ResultSet rs = null;
      ArrayList<DeptDTO> list = null;
      DeptDTO dto = null;

      int deptno;
      String dname;
      String loc;

      try {
         pstmt = conn.prepareStatement(sql);
         pstmt.setString(1, searchWord);
         rs = pstmt.executeQuery();

         if ( rs.next() ) {
            list = new ArrayList<DeptDTO>();
            do {
               deptno = rs.getInt("deptno");
               dname = rs.getString("dname");
               loc = rs.getString("loc");

               dto = new DeptDTO(deptno, dname, loc);
               list.add(dto);

            } while (rs.next());
         }

      } catch (SQLException e) {
         e.printStackTrace();
      } finally {
         try {
            rs.close();
            pstmt.close();
         } catch (SQLException e) { 
            e.printStackTrace();
         }
      }

      // 출력
      if (list == null) {
         System.out.println("> 검색된 부서 정보는 존재하지 않습니다.");
      }else {
         Iterator<DeptDTO> ir = list.iterator();
         while (ir.hasNext()) {
            dto =  ir.next();
            System.out.println( dto );
         }
      }
   }
}
```



---

**예외**

`SQLException` 

1. Connection.createStatement 
2. Statement.executeQuery
3. Statement.close
4. ResultSet.close

`FileNotFoundException` new FileReader 

`IOException` 

> 테이블명과 칼럼명은 바인딩변수로 사용할 수 없고 칼럼값만 된다.

`rs.setString(1, "%" + searchWord + "%")` LIKE 에는 % 를 붙인다.

**문제**

 * 문제) 사원 정보 검색해서 출력
 * deptno, dname, empno, ename, hiredate
 * ename 's' 'S' 포함하는 사원 정보만 조회

```java
Connection conn = DBConn.getConnection();
String sql = 
    "SELECT e.deptno, dname, empno, ename, hiredate "
    + "FROM emp e JOIN dept d ON e.deptno = d.deptno "
    + "WHERE regexp_like(ename, ?, 'i') ";

PreparedStatement st = null;
ResultSet rs = null;
ArrayList<EmpDeptDTO> list = new ArrayList<>();

try {
    st = conn.prepareStatement(sql);
    String searchWord = "s";
    st.setString(1, searchWord );
    rs = st.executeQuery();

    while (rs.next()) {
        int deptno = rs.getInt("deptno");
        int empno = rs.getInt("empno");
        String dname = rs.getString("dname");
        String ename = rs.getString("ename");
        Date hiredate = rs.getDate("hiredate");
        EmpDeptDTO dto = new EmpDeptDTO(deptno, empno, dname, ename, hiredate);
        list.add(dto);
    }
} catch (SQLException e) {
    e.printStackTrace();
} finally {
    try {
        st.close();
        rs.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    DBConn.close();
}

for (EmpDeptDTO dto : list) {
    System.out.println(dto);
}
```

> 구글링해보면 using 이 더 좋은코드라고 하는데 쌤은 using 이 잘 안쓰인다고 하셨다.. JOIN ON 을 쓰시라고.. 왜그럴까..

> DTO 객체를 하나만 만들고 if - do - while 을 사용하는게 더 좋은 코드이다. 

> State, ResultSet, DBConn 세 개를 꼭 닫는다.

```java
String sql = 
    "SELECT deptno, dname, empno, ename, hiredate "
    + "FROM emp e JOIN dept d ON e.deptno = d.deptno "
    + "WHERE regexp_like(ename, ?, 'i') ";
```

> regexp_like 에 'i' 에는 작은 따옴표가 자동으로 들어가지 않으므로 빼먹지 않을 것.

**문제2**

salgrade, emp 테이블을 이용해서 아래 결과와 같이 나오도록 코딩

```
1등급 ( 700~1200 ) - 2명
2등급 ( 1201~1400 ) - 3명
3등급 ( 1401~2000 ) - 2명
4등급 ( 2001~3000 ) - 4명
5등급 ( 3001~9999 ) - 1명
```



**코드**

```java
Connection conn = DBConn.getConnection();
String sql = 
    "SELECT grade, losal, hisal, count(*) "
    + "FROM emp JOIN salgrade ON sal BETWEEN losal AND hisal "
    + "GROUP BY grade, losal, hisal "
    + "ORDER BY grade";

ArrayList<Emp> list = new ArrayList<>();
Emp emp;

PreparedStatement st = null;
ResultSet rs = null;

try {
    st = conn.prepareStatement(sql);
    rs = st.executeQuery();

    if (rs.next()) {
        do {
            int grade = rs.getInt("grade");
            int hisal = rs.getInt("hisal");
            int losal = rs.getInt("losal");
            int count = rs.getInt("count(*)");
            emp = new Emp(grade, hisal, losal, count);

            list.add(emp);

        } while (rs.next());
    }
} catch (SQLException e) {
    e.printStackTrace();
} finally {
    try {
        st.close();
        rs.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    DBConn.close();

}

Iterator<Emp> ir = list.iterator();

while (ir.hasNext()) {
    Emp e = ir.next();

    System.out.printf("%d등급 ( %d~%d ) - %d명\n", e.getGrade(), e.getLosal(), e.getHisal(), e.getCount());
}
```



Lobok 은 자동으로 getter, setter 를 만들어준다.

Spring 에서 배운다.



**문제3**

```
1등급   (    700~1200 ) - 2명
20 	 RESEARCH 	 7369 	 SMITH 	 800.00 
30 	 SALES 	 7900 	 JAMES 	 950.00 

2등급   (    1201~1400 ) - 3명
10 	 ACCOUNTING 	 7934 	 MILLER 	 1300.00 
30 	 SALES 	 7654 	 MARTIN 	 1250.00 
30 	 SALES 	 7521 	 WARD 	 1250.00 

3등급   (    1401~2000 ) - 2명
30 	 SALES 	 7844 	 TURNER 	 1500.00 
30 	 SALES 	 7499 	 ALLEN 	 1600.00 

4등급   (    2001~3000 ) - 4명
10 	 ACCOUNTING 	 7782 	 CLARK 	 2450.00 
20 	 RESEARCH 	 7902 	 FORD 	 3000.00 
20 	 RESEARCH 	 7566 	 JONES 	 2975.00 
30 	 SALES 	 7698 	 BLAKE 	 2850.00 

5등급   (    3001~9999 ) - 1명
10 	 ACCOUNTING 	 7839 	 KING 	 5000.00 
```

**코드**

```java
Connection conn = DBConn.getConnection();
String sql = "SELECT grade, losal, hisal, count(*) " + "FROM emp JOIN salgrade ON sal BETWEEN losal AND hisal "
    + "GROUP BY grade, losal, hisal " + "ORDER BY grade";

ArrayList<SalgradeDTO> list = new ArrayList<>();
SalgradeDTO dto = null;

PreparedStatement st = null;
ResultSet rs = null;

try {
    st = conn.prepareStatement(sql);
    rs = st.executeQuery();

    if (rs.next()) {
        do {
            int grade = rs.getInt("grade");
            int hisal = rs.getInt("hisal");
            int losal = rs.getInt("losal");
            int count = rs.getInt("count(*)");
            dto = new SalgradeDTO(grade, hisal, losal, count);

            list.add(dto);

        } while (rs.next());
    }
} catch (SQLException e) {
    e.printStackTrace();
} finally {
    try {
        st.close();
        rs.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }

}

// 출력. 1등급 ( 700~1200 ) - 2명
ArrayList<EmpDTO> empList = null;
ResultSet empRs = null;
PreparedStatement empPstmt = null;
String empSql = "SELECT d.deptno, dname,   empno,    ename,   sal , s.grade "
    + "FROM emp e LEFT JOIN dept d ON e.deptno = d.deptno "
    + "           JOIN salgrade s on  e.sal BETWEEN s.losal AND s.hisal  " + "WHERE s.grade = ?   ";

if (list == null) {
    System.out.println("> 결과물 X");
} else {
    try {
        empPstmt = conn.prepareStatement(empSql);
        Iterator<SalgradeDTO> ir = list.iterator();

        while (ir.hasNext()) {
            dto = ir.next();
            System.out.printf("%d등급   (    %d~%d ) - %d명\n", dto.getGrade(), dto.getLosal(), dto.getHisal(),
                              dto.getCount());

            int grade = dto.getGrade(); // 1, 2, 3, 4, 5
            empPstmt = conn.prepareStatement(empSql);
            empPstmt.setInt(1, grade);
            empRs = empPstmt.executeQuery();

            if (empRs.next()) {
                empList = new ArrayList<>();
                do {
                    empRs.getInt(1);
                    empRs.getString(2);
                    empRs.getInt(3);
                    empRs.getString(4);
                    empRs.getDouble(5);

                    System.out.printf("%d \t %s \t %d \t %s \t %.2f \n", empRs.getInt(1), empRs.getString(2),
                                      empRs.getInt(3), empRs.getString(4), empRs.getDouble(5));
                } while (empRs.next());
            }
            //					empRs.close();
            //					empPstmt.close();
        } // while
    } catch (SQLException e) {
        e.printStackTrace();
    }
} // if
DBConn.close();
```

> LEFT JOIN 의 이유

**Map 에 담기** 

```
1등급   (    1200~700 ) - 2명
	20		7369	SMITH	800.00
	30		7900	JAMES	950.00
2등급   (    1400~1201 ) - 3명
	10		7934	MILLER	1300.00
	30		7654	MARTIN	1250.00
	30		7521	WARD	1250.00
3등급   (    2000~1401 ) - 2명
	30		7844	TURNER	1500.00
	30		7499	ALLEN	1600.00
4등급   (    3000~2001 ) - 4명
	10		7782	CLARK	2450.00
	20		7902	FORD	3000.00
	20		7566	JONES	2975.00
	30		7698	BLAKE	2850.00
5등급   (    9999~3001 ) - 1명
	10		7839	KING	5000.00
```

```java
public class Ex03_04 {
	public static void main(String[] args) {
		String sql = "SELECT grade, losal, hisal, count(*) cnt "
				+ "FROM emp JOIN salgrade ON sal BETWEEN losal AND hisal " + "GROUP BY grade, losal, hisal  "
				+ "ORDER BY grade";
		String empSql = "SELECT d.deptno, dname,   empno,    ename,   sal , s.grade "
				+ "FROM emp e LEFT JOIN dept d ON e.deptno = d.deptno "
				+ "           JOIN salgrade s on  e.sal BETWEEN s.losal AND s.hisal  " + "WHERE s.grade = ?   ";

		Connection conn = DBConn.getConnection();
		PreparedStatement pstmt = null, empPstmt = null;
		ResultSet rs = null, empRs = null;
		LinkedHashMap<SalgradeDTO, ArrayList<EmpDTO>> map = null;
		ArrayList<EmpDTO> empList = null;
		SalgradeDTO dto = null;
		EmpDTO empDto = null;

		try {
			pstmt = conn.prepareStatement(sql);
			rs = pstmt.executeQuery();

			if (rs.next()) {
				map = new LinkedHashMap<>();
				do {
					dto = new SalgradeDTO(rs.getInt(1), rs.getInt(2), rs.getInt(3), rs.getInt(4));
					// 해당 등급의 사원정보를 가지는 ArrayList<EmpDTO> empList 생성해서
					int grade = rs.getInt(1);
					empPstmt = conn.prepareStatement(empSql);
					empPstmt.setInt(1, grade);
					empRs = empPstmt.executeQuery();

					if (empRs.next()) {
						empList = new ArrayList<EmpDTO>();
						do {
							// d.deptno, dname, empno, ename, sal , s.grade
							int deptno = empRs.getInt(1); // deptno
							String dname = empRs.getString(2); // dname
							int empno = empRs.getInt(3); // empno
							String ename = empRs.getString(4); // ename
							double sal = empRs.getDouble(5);// sal

							empDto = new EmpDTO();
							empDto.setDeptno(deptno);
							empDto.setEmpno(empno);
							empDto.setEname(ename);
							empDto.setSal(sal);

							empList.add(empDto);

						} while (empRs.next());
					} // if
						// key value == entry
					map.put(dto, empList);

					empPstmt.close();
					empRs.close();
				} while (rs.next());

			} // if

		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				pstmt.close();
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		DBConn.close();
		//

		// 출력. 1등급 ( 700~1200 ) - 2명
		dispMap(map);

	} // main

	private static void dispMap(LinkedHashMap<SalgradeDTO, ArrayList<EmpDTO>> map) {

		Set<Entry<SalgradeDTO, ArrayList<EmpDTO>>> set = map.entrySet();
		Iterator<Entry<SalgradeDTO, ArrayList<EmpDTO>>> ir = set.iterator();

		while (ir.hasNext()) {
			Entry<SalgradeDTO, ArrayList<days02.EmpDTO>> entry = ir.next();
			SalgradeDTO dto = entry.getKey();
			System.out.printf("%d등급   (    %d~%d ) - %d명\n", dto.getGrade(), dto.getLosal(), dto.getHisal(),
					dto.getCnt());

			ArrayList<EmpDTO> empList = entry.getValue();
			Iterator<EmpDTO> e_ir = empList.iterator();

			while (e_ir.hasNext()) {
				EmpDTO edto = e_ir.next();
				System.out.printf("\t%d\t%s\t%d\t%s\t%.2f\n", edto.getDeptno(), "", edto.getEmpno(), edto.getEname(),
						edto.getSal());
			} //
		} // while
	} // dispMap
} // class
```

**[게시판]**

게시판: 글쓰기, 수정, 삭제, 조회 등등

[MVC 패턴]

1. BoardDTO 객체
2. Board (Dao) 인터페이스 선언
3. BoardDaoImpl 선언
4. BoardService 선언
   - 예) [해당 게시글 보기] = 1) 해당 게시글 조회수 증가 + 2) 해당 게시글 SELECT 
   - 3)) 로그 기록
   - 4)) 트랜잭션 처리
5. BoardController 선언
6. Ex04.main(){ }

ASP.NET - 외부 제공 강좌들 탭의 글들

**BoardDTO**

```java
public class BoardDTO {
	private int seq;
	private String writer;
	private String pwd;
	private String email;
	private String title;
	private Date writedate;
	private int readed;
	private int tag;
	private Clob content;

	public BoardDTO(int seq, String writer, String pwd, String email, String title, Date writedate, int readed,
			int tag, Clob content) {
		super();
		this.seq = seq;
		this.writer = writer;
		this.pwd = pwd;
		this.email = email;
		this.title = title;
		this.writedate = writedate;
		this.readed = readed;
		this.tag = tag;
		this.content = content;
	}

	public int getSeq() {
		return seq;
	}

	public void setSeq(int seq) {
		this.seq = seq;
	}

	public String getWriter() {
		return writer;
	}

	public void setWriter(String writer) {
		this.writer = writer;
	}

	public String getPwd() {
		return pwd;
	}

	public void setPwd(String pwd) {
		this.pwd = pwd;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public Date getWritedate() {
		return writedate;
	}

	public void setWritedate(Date writedate) {
		this.writedate = writedate;
	}

	public int getReaded() {
		return readed;
	}

	public void setReaded(int readed) {
		this.readed = readed;
	}

	public int getTag() {
		return tag;
	}

	public void setTag(int tag) {
		this.tag = tag;
	}

	public Clob getContent() {
		return content;
	}

	public void setContent(Clob content) {
		this.content = content;
	}

	@Override
	public String toString() {
		return "BoardDTO [seq=" + seq + ", writer=" + writer + ", pwd=" + pwd + ", email=" + email + ", title=" + title
				+ ", writedate=" + writedate + ", readed=" + readed + ", tag=" + tag + ", content=" + content + "]";
	}
}
```

**BoardDAO**

```java
public interface BoardDAO {
	
	// 1. 모든 게시글 목록 반환하는 메서드 선언
	ArrayList<BoardDTO> select() throws SQLException;

	// 2. 새로운 게시글 추가하는 메서드 선언
	int insert(BoardDTO dto) throws SQLException;
}
```

**BoardDAOImpl**

```java
```



**SQL**

```sql
INSERT INTO tbl_cstvsboard (seq, writer, pwd, email, title, tag, content)
VALUES (seq_tbl_cstvsBoard.NEXTVAL, ?, ?, ?, ?, ?, ?)
```



**단위테스트** 

3번 BoardDAOImpl 선언한 것 INSERT, SELECT 테스트하는 것

**JUnit Test Case**

New 4 Test 로 생성

```java
public class BoardDAOImplTest {

	@Test
	public void select_test() {
		Connection conn = DBConn.getConnection();
		BoardDAOImpl dao = new BoardDAOImpl(conn);
		
		try {
			ArrayList<BoardDTO> list = dao.select();
			Iterator<BoardDTO> ir = list.iterator();
			
			while (ir.hasNext()) {
				BoardDTO boardDTO = ir.next();
				System.out.println(boardDTO);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
}
```

우클릭 - run as - JUnit Test

